---
title: "Thesis Workflow"
author: "Neil Kester"
date: "4/15/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,messages=FALSE)
```

# Purpose  

# Preparation

## Create a Simulation and Entity Table  

First, it is useful to understand information about the sensors and the entities that carried them in the specific "Design Point" and "Iteration" under evaluation. First, lets load the required query and connection object information and then execute the function.   

```{r}

source("./connectionObjects/entityMappingConnectionObj.R")

entitySensorMapping <- modSim::mapSensorsAndEntities(mongoUri = mongoUri,
                              mongoDb = mongoDb,
                              mongoCollection = sensorIDNameCollection,
                              mongoFields = sensorIDNameFields,
                              mongoQuery = sensorIDNameQuery)


```  


### Sensory Description  

```{r}

entitySensorMapping$SensorDescription

```  

### Entity ID to Entity Name  

```{r}

entitySensorMapping$EntityIdToName

```

### Sensor ID to Entity ID  

```{r}

entitySensorMapping$SensorToEntityId

```

### Unnested Sensor State 

This is the full data set produced by the input query.  

```{r}

entitySensorMapping$UnnestedSensorState

```
























## Create a Line of Sight Table  

This table describes when a sensor target has Line of Sight (LOS). This does not mean they have acquired each other but rather that their line of sight is not obstructed.  

```{r}

source("./connectionObjects/hasLosConnectionObj.R")

LosData <- modSim::mongoUnnest(mongoUri = mongoUri,
                               mongoDb = mongoDb,
                               mongoCollection = losMongoCollection,
                               mongoQuery = losMongoQuery,
                               mongoFields = losMongoFields,
                               unnestCols = "event")

```  

```{r}

LosData

```

## Sensor Target Acquisitions

Unlike the LOS table, this table shows the state of acquisition between each sensor target pair. It also shows the previous acquisition state so we can determine when the acquistion level changes.  

```{r}

source("./connectionObjects/acqConnectionObj.R")

sensorAcq <- modSim::sensorAcquisition(mongoUri = mongoUri,
                          mongoDb = mongoDb,
                          mongoCollection = acqMongoCollection,
                          mongoQuery = acqMongoQuery,
                          mongoFields = acqMongoFields,
                          recursiveUnnests = c("event",
                                               "messageData", 
                                               "any", 
                                               "sensorDetection"))
```



# Compile Tables  

Using the reference tables created in last section, we will transform them into useful information.

## Sensing Entities  

I only care about Entities (vehicles) that have sensors so I'll drop all entities not in the `SensorToEntityId` table. Then I'll add the description of each sensor and reorder the columns.

```{r}

requireNamespace("magrittr")

humanNameToSensor <- dplyr::left_join(x = entitySensorMapping$EntityIdToName,
                                      y = entitySensorMapping$SensorToEntityId,
                                      by = "entityId") %>%
  dplyr::left_join(x = .,
                   y = entitySensorMapping$SensorDescription,
                   by = "sensorId") %>%
  dplyr::mutate(pltLevelName = stringr::str_extract(string = source,
                                                 pattern = "[^/]*/[^/]*/[^/]*$"),
                shortName =  stringr::str_extract(string = source,
                                                 pattern = "[^/]*$")) %>%
  dplyr::select(shortName,
                pltLevelName,
                acquireSensorType,
                magnification,
                entityId,
                sensorId,
                source)

humanNameToSensor
```

Now that I understand the entities and their sensors, I'll select one entity at a time, starting with `EPBV 90 2`.  

```{r}

entity_epbv_90_2 <- humanNameToSensor %>%
  dplyr::filter(shortName == "EPBV 90 2")

entity_epbv_90_2
```  

### What Can EPBV 90 2 See Over Time  

First, lets look at what LOS EPBV 90 2 has for each target over time. I'll select only the columns of information I need and filter out all sensors except those on the `EPBV 90 2` platform. 

```{r}

entity_epbv_90_2_los <- LosData %>%
  dplyr::select(sensorId,targetId,time,hasLOS) %>%
  dplyr::filter(sensorId %in% entity_epbv_90_2$sensorId)


entity_epbv_90_2_los
```
That data frame looks good. Finally, I'll filter to see if any of the sensors EVER do not have line of sight with any of the targets.  

```{r}

entity_epbv_90_2_los %>%
    dplyr::filter(isFALSE(hasLOS))

```
It turns out this vehicle can always see all targets.  

I'll run through all the others to see if any lose LOS.  

```{r}

entIds <- dplyr::distinct(humanNameToSensor,entityId)[[1]]

LosResponses <- list()

LosDataSubset <- LosData %>%
  dplyr::select(sensorId,targetId,time,hasLOS)

for(entId in entIds){
  
  testEntity <- dplyr::filter(humanNameToSensor,entityId == entId)

  entName <- dplyr::distinct(testEntity,shortName)[[1]]
  
  LosResponses[entName] <- LosDataSubset %>%
    dplyr::filter(sensorId %in% testEntity$sensorId) %>%
    dplyr::filter(isFALSE(hasLOS))
  
}

LosResponses

```

```{r}

entitySensorMapping$SensorDescription

entitySensorMapping$EntityIdToName

```



```{r}

entitySensorMapping$EntityIdToName

```

```{r}

entitySensorMapping$SensorToEntityId

```







