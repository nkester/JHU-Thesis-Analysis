---
title: 'Step 2: Query MongoDB, transform data, and write to PostreSQL DB'
author: "Neil Kester"
date: "4/24/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      messages = FALSE)
```

# Purpose

These functions execute the extract, transform, and load (ETL) steps taking the data required to support analysis from the simulation's MongoDB logs, structuring and relating it, and then loading it into a relational database (in this case PostgreSQL) in preparation for later analysis.  

# Low Functions  

## Sensor to Entity Mapping  

This is already implemented in my `{modSim}` package.

**Work to do: Confirm `SensorDescription`, `EntityIdToName`, and `SensorToEntityId` does not need to be split out by iteration. I think not**

**__Note__: This query should not include an iteration filter. Ideally, this is used once per design point.**

```{r}

source("./connectionObjects/entityMappingConnectionObj.R")

function(mongoConnParam){
  
  requireNamespace(package = "magrittr")
  
}

{ # Extract ----
  
  { # Query MongoDb and unnest information about sensors and entities ----
    
    entitySensorMapping <- modSim::mapSensorsAndEntities(mongoUri = mongoConnParam[["mongoUri"]],
                                                         mongoDb = mongoConnParam[["mongoDb"]],
                                                         mongoCollection = mongoConnParam[["collection"]],
                                                         mongoFields = mongoConnParam[["fields"]],
                                                         mongoQuery = mongoConnParam[["query"]])
    
    metaData <- entitySensorMapping$UnnestedSensorState %>%
      dplyr::distinct(.data = .,
                      runId,
                      designPoint,
                      iteration)
    
  } # close Query MongoDb and unnest information about sensors and entities section
  
} # close Extract section

{ # Transform and Load ----
  
  { # sensorDescription ----
    
    entitySensorMapping$SensorDescription <- entitySensorMapping$SensorDescription %>%
      dplyr::mutate(.data = .,
                    designPoint = dplyr::distinct(metaData,
                                                  designPoint)[[1]],
                    sensorId_pkId = NA)
    
    query_sensorDescription <- fillTableQuery(data = entitySensorMapping$SensorDescription,
                                              tableName = paste0("\"sensorDescription\" (",
                                                                 paste0("\"",
                                                                        names(entitySensorMapping$SensorDescription),
                                                                        "\"",
                                                                        collapse = ","),
                                                                 ")"))
    
    #> This is required because pg uses the unquoted `DEFAULT` for its auto-incrementing columns.
    query_sensorDescription <- stringr::str_replace_all(string = query_sensorDescription,
                                                        pattern = "NULL",
                                                        replacement = "DEFAULT")
    
    sendPgFillTableQuery(query = query_sensorDescription,
                         host = pgConnParam[["pgHost"]],
                         port = pgConnParam[["pgPort"]],
                         user = pgConnParam[["pgUser"]],
                         password = pgConnParam[["pgPass"]],
                         dbname = pgConnParam[["pgDb"]])
    
    rm(query_sensorDescription)
    
  } # close sensorDescription section
  
  { # entityIdToName ----
    
    entitySensorMapping$EntityIdToName <- entitySensorMapping$EntityIdToName %>%
      dplyr::mutate(.data = .,
                    designPoint = dplyr::distinct(metaData,
                                                  designPoint)[[1]],
                    force = dplyr::case_when(
                      stringr::str_detect(string = source,
                                          pattern = "^(?i)(blueforce)") ~ "BLUEFORCE",
                      stringr::str_detect(string = source,
                                          pattern = "^(?i)(redforce)") ~ "REDFORCE",
                      TRUE ~ "OTHER"
                    ),
                    shortName = stringr::str_extract(string = source,
                                                     pattern = "[^/]*$"),
                    entityId_pkId = NA)
    
    query_entityIdToName <- fillTableQuery(data = entitySensorMapping$EntityIdToName,
                                           tableName = paste0("\"entityIdToName\" (",
                                                              paste0("\"",
                                                                     names(entitySensorMapping$EntityIdToName),
                                                                     "\"",
                                                                     collapse = ","),
                                                              ")"))
    
     #> This is required because pg uses the unquoted `DEFAULT` for its auto-incrementing columns.
    query_entityIdToName <- stringr::str_replace_all(string = query_entityIdToName,
                                                        pattern = "NULL",
                                                        replacement = "DEFAULT")
    
    sendPgFillTableQuery(query = query_entityIdToName,
                         host = pgConnParam[["pgHost"]],
                         port = pgConnParam[["pgPort"]],
                         user = pgConnParam[["pgUser"]],
                         password = pgConnParam[["pgPass"]],
                         dbname = pgConnParam[["pgDb"]])
    
    rm(query_entityIdToName)
    
  } # close entityIdToName section
  
  { # sensorToEntityId ---- 
    
    entitySensorMapping$SensorToEntityId <- entitySensorMapping$SensorToEntityId %>%
      dplyr::mutate(.data = .,
                    designPoint = dplyr::distinct(metaData,
                                                  designPoint)[[1]],
                    sensorToEntityId_pkId = NA)
    
    query_sensorToEntityId <- fillTableQuery(data = entitySensorMapping$SensorToEntityId,
                                           tableName = paste0("\"sensorToEntityId\" (",
                                                              paste0("\"",
                                                                     names(entitySensorMapping$SensorToEntityId),
                                                                     "\"",
                                                                     collapse = ","),
                                                              ")"))
    
     #> This is required because pg uses the unquoted `DEFAULT` for its auto-incrementing columns.
    query_sensorToEntityId <- stringr::str_replace_all(string = query_sensorToEntityId,
                                                        pattern = "NULL",
                                                        replacement = "DEFAULT")
    
    sendPgFillTableQuery(query = query_sensorToEntityId,
                         host = pgConnParam[["pgHost"]],
                         port = pgConnParam[["pgPort"]],
                         user = pgConnParam[["pgUser"]],
                         password = pgConnParam[["pgPass"]],
                         dbname = pgConnParam[["pgDb"]])
    
    rm(query_sensorToEntityId)
    
  } # close sensorToEntityId section
  
} # close Transform and Load section

```

```{r scratch}

pgConn <- DBI::dbConnect(drv = RPostgreSQL::PostgreSQL(),
                         host = pgConnParam[["pgHost"]],
                         port = pgConnParam[["pgPort"]],
                         user = pgConnParam[["pgUser"]],
                         password = pgConnParam[["pgPass"]],
                         dbname = pgConnParam[["pgDb"]])

DBI::dbSendQuery(conn = pgConn,
                 statement = createSensorToEntityIdTable)

DBI::dbListTables(conn = pgConn)

DBI::dbListFields(conn = pgConn,
                  name = "entityIdToName")

DBI::dbGetQuery(conn = pgConn,
               statement = "SELECT * FROM \"sensorToEntityId\"")

DBI::dbSendQuery(conn = pgConn,
                 statement = "DROP TABLE \"sensorToEntityId\"")

DBI::dbDisconnect(conn = pgConn)

rm(pgConn)

```

